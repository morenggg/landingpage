<!doctype html>
<html lang="de">
  
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Dorfdulli Racing ‚Äì MX 3D Runner</title>
  <style>
    :root { --bg:#070707; --fg:#f2f2f2; --muted:rgba(255,255,255,.65); }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    .wrap{max-width:980px;margin:0 auto;padding:14px 14px 92px}
    h1{font-size:22px;margin:6px 0 6px}
    p{margin:0 0 10px;color:var(--muted)}
    .hud{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin:10px 0 12px}
    .chip{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);border-radius:999px;padding:8px 12px;font-size:14px}
    button{background:rgba(255,255,255,.08);color:var(--fg);border:1px solid rgba(255,255,255,.18);border-radius:12px;padding:10px 12px;font-size:14px}
    button:active{transform:translateY(1px)}
    canvas{width:100%;height:auto;border-radius:18px;border:1px solid rgba(255,255,255,.12);touch-action:none;background:
      radial-gradient(120% 90% at 60% 20%, #1a1a1a 0%, #0a0a0a 55%, #050505 100%)}
    .controls{
      position:fixed;left:0;right:0;bottom:0;
      padding:12px 14px calc(12px + env(safe-area-inset-bottom));
      backdrop-filter:blur(10px);
      background:linear-gradient(to top, rgba(0,0,0,.78), rgba(0,0,0,.22));
      border-top:1px solid rgba(255,255,255,.10);
      display:flex;justify-content:center
    }
    .pad{max-width:980px;width:100%;display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:10px}
    .pad button{height:56px;font-size:16px;border-radius:16px}
    .note{font-size:12px;color:rgba(255,255,255,.55);margin-top:8px}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>üèÅ MX 3D Runner</h1>
    <p>Handy: Buttons unten. PC: ‚Üê ‚Üí lenken, ‚Üë Gas, ‚Üì Bremse, R Restart. H√ºgel = Airtime üòÑ</p>

    <div class="hud">
      <div class="chip" id="spd">Speed: 0</div>
      <div class="chip" id="dst">Dist: 0</div>
      <div class="chip" id="air">Air: 0.0s</div>
      <div class="chip" id="st">Status: Ready</div>
      <button id="rs" type="button">Restart</button>
    </div>

    <canvas id="c" width="980" height="540"></canvas>
    <div class="note">Pro Tipp: vor Spr√ºngen Gas halten, in der Luft leicht gegenlenken. üòà</div>
  </div>

  <div class="controls">
    <div class="pad">
      <button id="brk" type="button">üõë Bremse</button>
      <button id="l" type="button">‚¨ÖÔ∏è Links</button>
      <button id="r" type="button">‚û°Ô∏è Rechts</button>
      <button id="gas" type="button">üî• Gas</button>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const elSpd = document.getElementById("spd");
  const elDst = document.getElementById("dst");
  const elAir = document.getElementById("air");
  const elSt  = document.getElementById("st");
  const btnRs = document.getElementById("rs");

  const btnGas = document.getElementById("gas");
  const btnBrk = document.getElementById("brk");
  const btnL   = document.getElementById("l");
  const btnR   = document.getElementById("r");

  const W = canvas.width, H = canvas.height;

  // --- Pseudo 3D road model (segments) ---
  const SEG_LEN = 26;          // world units per segment
  const DRAW_DIST = 220;       // number of segments to draw
  const ROAD_W = 2200;         // half width in world units
  const CAM_H = 1400;          // camera height
  const CAM_D = 0.84;          // projection depth factor

  // road palette
  const col = {
    skyTop: "rgba(255,255,255,0.10)",
    skyBot: "rgba(255,255,255,0.00)",
    grass1: "rgba(255,255,255,0.03)",
    grass2: "rgba(255,255,255,0.06)",
    road1:  "rgba(255,255,255,0.10)",
    road2:  "rgba(255,255,255,0.14)",
    edge:   "rgba(255,255,255,0.25)",
    line:   "rgba(255,255,255,0.30)"
  };

  // build track segments with curves + hills (jumps)
  const track = [];
  const TRACK_LEN = 5200;

  function add(n, curve, hill){
    for (let i=0;i<n;i++){
      track.push({ curve, hill });
    }
  }
  // helpers for "jumpy" hills
  function hillPulse(n, amp){
    for (let i=0;i<n;i++){
      const t = i/(n-1);
      const s = t*t*(3-2*t);         // smoothstep 0..1
      const v = Math.sin(t*Math.PI); // 0..1..0
      track.push({ curve: 0, hill: amp * v });
    }
  }

  // layout: straights, turns, whoops, jumps
  add(180, 0, 0);
  add(120, 0.6, 0);
  add(90,  0.0, 0);
  hillPulse(120, 1200);             // big tabletop jump feeling
  add(120, -0.75, 0);
  add(70,  0, 0);
  hillPulse(90, 900);               // medium jump
  // whoops: alternating small hills
  for (let i=0;i<160;i++){
    track.push({ curve: (i<80?0.25:-0.25), hill: (i%10<5?260:-260) });
  }
  add(180, 0, 0);
  hillPulse(140, 1400);             // big jump
  add(260, 0.35, 0);
  // fill to TRACK_LEN
  while (track.length < TRACK_LEN) add(60, 0, 0);

  // player state
  let crashed = false;
  let dist = 0;
  let airTime = 0;

  const p = {
    x: 0,           // lateral position in world units (center = 0)
    z: 0,           // camera position along track (world units)
    speed: 0,
    targetSpeed: 12.5,
    vy: 0,          // vertical velocity for airtime feeling
    y: CAM_H,       // vertical camera offset (base + hills)
    steer: 0
  };

  const keys = { gas:false, brk:false, left:false, right:false };

  function bindHold(btn, k) {
    const on  = (e)=>{ e.preventDefault(); keys[k]=true; };
    const off = (e)=>{ e.preventDefault(); keys[k]=false; };
    btn.addEventListener("pointerdown", on);
    btn.addEventListener("pointerup", off);
    btn.addEventListener("pointercancel", off);
    btn.addEventListener("pointerleave", off);
  }
  bindHold(btnGas,"gas");
  bindHold(btnBrk,"brk");
  bindHold(btnL,"left");
  bindHold(btnR,"right");

  window.addEventListener("keydown",(e)=>{
    if (e.key==="ArrowUp") keys.gas=true;
    if (e.key==="ArrowDown") keys.brk=true;
    if (e.key==="ArrowLeft") keys.left=true;
    if (e.key==="ArrowRight") keys.right=true;
    if (e.key.toLowerCase()==="r") reset();
  });
  window.addEventListener("keyup",(e)=>{
    if (e.key==="ArrowUp") keys.gas=false;
    if (e.key==="ArrowDown") keys.brk=false;
    if (e.key==="ArrowLeft") keys.left=false;
    if (e.key==="ArrowRight") keys.right=false;
  });

  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function segIndex(z){ return Math.floor(z / SEG_LEN) % track.length; }

  function project(wx, wy, wz, camX, camY, camZ){
    // camera space
    const dz = (wz - camZ);
    const scale = (CAM_D / dz);
    const x = (1 + scale*(wx - camX)/1000) * (W/2);
    const y = (1 - scale*(wy - camY)/1000) * (H*0.55);
    const w = scale * ROAD_W * (W/2) / 1000;
    return { x, y, w, scale };
  }

  function reset(){
    crashed=false;
    dist=0; airTime=0;
    p.x=0; p.z=0;
    p.speed=9.5; p.targetSpeed=13.0;
    p.vy=0; p.y=CAM_H;
    p.steer=0;
    elSt.textContent="Status: Running";
  }

  function crash(msg){
    crashed=true;
    elSt.textContent="Status: üí• " + msg;
  }

  function drawSky(){
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, col.skyTop);
    g.addColorStop(1, col.skyBot);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);
  }

  function drawQuad(x1,y1,w1, x2,y2,w2, fill, stroke){
    ctx.beginPath();
    ctx.moveTo(x1 - w1, y1);
    ctx.lineTo(x1 + w1, y1);
    ctx.lineTo(x2 + w2, y2);
    ctx.lineTo(x2 - w2, y2);
    ctx.closePath();
    ctx.fillStyle = fill;
    ctx.fill();
    if (stroke){
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }

  function drawBike(){
    // simple "bike" near bottom center, slightly offset by steering
    const bx = W/2 + (p.x/ROAD_W) * (W*0.22);
    const by = H*0.78 + (Math.sin(p.z*0.02)*2);

    // shadow
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.beginPath();
    ctx.ellipse(bx, by+34, 44, 14, 0, 0, Math.PI*2);
    ctx.fill();

    // bike body (stylized)
    ctx.save();
    const lean = clamp(p.steer * 0.55, -0.55, 0.55);
    ctx.translate(bx, by);
    ctx.rotate(lean);

    // wheels
    ctx.strokeStyle = "rgba(255,255,255,0.92)";
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.arc(-26, 20, 14, 0, Math.PI*2);
    ctx.arc( 26, 20, 14, 0, Math.PI*2);
    ctx.stroke();

    // frame
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(-26,20);
    ctx.lineTo(-4,-2);
    ctx.lineTo( 26,20);
    ctx.stroke();

    // rider
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.beginPath();
    ctx.arc(-6,-20,11,0,Math.PI*2);
    ctx.fill();

    // handlebars
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(4,-6);
    ctx.lineTo(22,-16);
    ctx.stroke();

    ctx.restore();

    if (crashed){
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "800 34px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      ctx.fillText("üí• CRASH! Restart", W/2, H*0.42);
    }
  }

  function hud(){
    elSpd.textContent = `Speed: ${p.speed.toFixed(1)}`;
    elDst.textContent = `Dist: ${Math.floor(dist)}m`;
    elAir.textContent = `Air: ${airTime.toFixed(1)}s`;
  }

  function frame(){
    // update
    if (!crashed){
      // steering
      const steerTarget = (keys.left ? -1 : 0) + (keys.right ? 1 : 0);
      p.steer += (steerTarget - p.steer) * 0.20;

      // speed control
      if (keys.gas) p.targetSpeed = 18.0; else p.targetSpeed = 13.5;
      if (keys.brk) p.targetSpeed = 6.5;

      p.speed += (p.targetSpeed - p.speed) * 0.05;
      p.speed = clamp(p.speed, 0, 22);

      // advance
      p.z += p.speed;
      dist += p.speed * 0.6;

      // look up segment
      const i = segIndex(p.z);
      const cur = track[i].curve;

      // lateral movement; harder at high speed
      p.x += p.steer * (120 + p.speed*18);
      // curve pushes you outward
      p.x -= cur * (p.speed * 95);

      // hills -> airtime feel: compare "current" hill vs "ahead" hill
      const hillNow = track[i].hill;
      const hillNext = track[(i+4)%track.length].hill;

      // if cresting (going down suddenly), launch a bit
      const crest = (hillNow - hillNext);
      p.vy += crest * 0.0018;
      // gravity
      p.vy -= 14.0;
      // integrate vertical
      p.y += p.vy * 0.035;

      const baseY = CAM_H + hillNow;
      // ground contact: don't go below base
      if (p.y < baseY){
        // in air
        airTime += 1/60;
      } else {
        // landed
        if (airTime > 0.18 && Math.abs(p.vy) > 240) crash("Hard landing");
        p.y = baseY;
        p.vy *= -0.10;
        airTime *= 0.80;
      }

      // crash if far offroad
      if (Math.abs(p.x) > ROAD_W * 1.05) crash("Off track");
    }

    // draw
    ctx.clearRect(0,0,W,H);
    drawSky();

    // draw road from far to near
    let x = 0;
    let z = p.z;
    let camX = p.x;
    let camY = p.y;
    let camZ = p.z;

    let maxY = H;
    let dx = 0;

    for (let n=0; n<DRAW_DIST; n++){
      const idx = segIndex(z + n*SEG_LEN);
      const seg = track[idx];

      dx += seg.curve; // accumulated curve for horizon bending
      const worldZ1 = z + n*SEG_LEN;
      const worldZ2 = z + (n+1)*SEG_LEN;

      const y1 = seg.hill;
      const y2 = track[segIndex(z + (n+1)*SEG_LEN)].hill;

      const p1 = project(x*1.0, y1, worldZ1, camX, camY, camZ);
      const p2 = project((x+dx)*1.0, y2, worldZ2, camX, camY, camZ);

      if (p2.y >= maxY) continue; // clip
      maxY = p2.y;

      const grass = (n % 2 === 0) ? col.grass1 : col.grass2;
      // grass quad (wide)
      drawQuad(W/2, p1.y, p1.w*2.3, W/2, p2.y, p2.w*2.3, grass);

      const road = (n % 2 === 0) ? col.road1 : col.road2;
      drawQuad(p1.x, p1.y, p1.w, p2.x, p2.y, p2.w, road, col.edge);

      // center line (thin)
      if (n % 6 < 3){
        ctx.strokeStyle = col.line;
        ctx.lineWidth = Math.max(1, 3*p2.scale);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
      }
    }

    drawBike();
    hud();

    requestAnimationFrame(frame);
  }

  btnRs.addEventListener("click", reset);
  reset();
  frame();
})();
</script>
</body>
</html>