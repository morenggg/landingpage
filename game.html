<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Dorfdulli Racing ‚Äì MX 3D</title>
  <style>
    :root { --bg:#070707; --fg:#f2f2f2; --muted:rgba(255,255,255,.65); }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    .wrap{max-width:980px;margin:0 auto;padding:14px 14px 92px}
    h1{font-size:22px;margin:6px 0 6px}
    p{margin:0 0 10px;color:var(--muted)}
    .hud{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin:10px 0 12px}
    .chip{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);border-radius:999px;padding:8px 12px;font-size:14px}
    button{background:rgba(255,255,255,.08);color:var(--fg);border:1px solid rgba(255,255,255,.18);border-radius:12px;padding:10px 12px;font-size:14px}
    button:active{transform:translateY(1px)}
    canvas{
      width:100%;height:auto;border-radius:18px;border:1px solid rgba(255,255,255,.12);
      touch-action:none;
      background: radial-gradient(120% 90% at 60% 20%, #1a1a1a 0%, #0a0a0a 55%, #050505 100%);
      display:block;
    }
    .controls{
      position:fixed;left:0;right:0;bottom:0;
      padding:12px 14px calc(12px + env(safe-area-inset-bottom));
      backdrop-filter:blur(10px);
      background:linear-gradient(to top, rgba(0,0,0,.78), rgba(0,0,0,.22));
      border-top:1px solid rgba(255,255,255,.10);
      display:flex;justify-content:center
    }
    .pad{max-width:980px;width:100%;display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:10px}
    .pad button{height:56px;font-size:16px;border-radius:16px}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>üèÅ MX 3D</h1>
    <p>Handy: Buttons unten. PC: ‚Üê ‚Üí lenken, ‚Üë Gas, ‚Üì Bremse, R Restart.</p>

    <div class="hud">
      <div class="chip" id="spd">Speed: 0</div>
      <div class="chip" id="dst">Dist: 0</div>
      <div class="chip" id="air">Air: 0.0s</div>
      <div class="chip" id="st">Status: Ready</div>
      <button id="rs" type="button">Restart</button>
    </div>

    <canvas id="c" width="980" height="560"></canvas>
  </div>

  <div class="controls">
    <div class="pad">
      <button id="brk" type="button">üõë Bremse</button>
      <button id="l" type="button">‚¨ÖÔ∏è Links</button>
      <button id="r" type="button">‚û°Ô∏è Rechts</button>
      <button id="gas" type="button">üî• Gas</button>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const elSpd = document.getElementById("spd");
  const elDst = document.getElementById("dst");
  const elAir = document.getElementById("air");
  const elSt  = document.getElementById("st");
  const btnRs = document.getElementById("rs");

  const btnGas = document.getElementById("gas");
  const btnBrk = document.getElementById("brk");
  const btnL   = document.getElementById("l");
  const btnR   = document.getElementById("r");

  const W = canvas.width, H = canvas.height;

  // --- helpers
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

  // --- pseudo 3D road constants
  const SEG_LEN   = 24;
  const DRAW_DIST = 230;
  const ROAD_W    = 2400;        // half width
  const CAM_H     = 1600;
  const CAM_D     = 0.86;

  const col = {
    skyTop:"rgba(255,255,255,0.10)", skyBot:"rgba(255,255,255,0.00)",
    grass1:"rgba(255,255,255,0.02)", grass2:"rgba(255,255,255,0.05)",
    dirt1:"rgba(210,170,120,0.14)",  dirt2:"rgba(210,170,120,0.18)",
    edge:"rgba(255,255,255,0.22)",
    rut:"rgba(0,0,0,0.18)",
    line:"rgba(255,255,255,0.10)"
  };

  function project(wx, wy, wz, camX, camY, camZ){
    const dz = (wz - camZ);
    if (dz <= 0.1) return null;
    const scale = (CAM_D / dz);
    const x = (1 + scale*(wx - camX)/1000) * (W/2);
    const y = (1 - scale*(wy - camY)/1000) * (H*0.58);
    const w = scale * ROAD_W * (W/2) / 1000;
    return { x, y, w, scale };
  }

  function quad(x1,y1,w1, x2,y2,w2, fill, stroke){
    ctx.beginPath();
    ctx.moveTo(x1-w1, y1);
    ctx.lineTo(x1+w1, y1);
    ctx.lineTo(x2+w2, y2);
    ctx.lineTo(x2-w2, y2);
    ctx.closePath();
    ctx.fillStyle = fill;
    ctx.fill();
    if (stroke){
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }

  function sky(){
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, col.skyTop);
    g.addColorStop(1, col.skyBot);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);
  }

  // --- Track generation (curves + jumps)
  const track = [];
  const TRACK_LEN = 6000;

  function add(n, curve, hill){
    for(let i=0;i<n;i++) track.push({ curve, hill });
  }
  function hillPulse(n, amp){
    for(let i=0;i<n;i++){
      const t = i/(n-1);
      const v = Math.sin(t*Math.PI); // 0..1..0
      track.push({ curve: 0, hill: amp*v });
    }
  }

  add(140, 0, 0);
  add(130, 0.55, 0);
  hillPulse(120, 1250);      // jump
  add(100, -0.75, 0);
  // whoops
  for(let i=0;i<200;i++){
    track.push({ curve: (i<100?0.22:-0.22), hill: (i%12<6?260:-260) });
  }
  hillPulse(150, 1500);      // big jump
  add(220, 0.35, 0);
  add(120, -0.40, 0);
  hillPulse(110, 900);
  while(track.length < TRACK_LEN) add(120, 0, 0);

  function segIndex(z){ return Math.floor(z / SEG_LEN) % track.length; }


  // --- Input
  const keys = { gas:false, brk:false, left:false, right:false };

  function bindHold(btn, k){
    const on=(e)=>{ e.preventDefault(); keys[k]=true; };
    const off=(e)=>{ e.preventDefault(); keys[k]=false; };
    btn.addEventListener("pointerdown", on);
    btn.addEventListener("pointerup", off);
    btn.addEventListener("pointercancel", off);
    btn.addEventListener("pointerleave", off);
  }
  bindHold(btnGas,"gas");
  bindHold(btnBrk,"brk");
  bindHold(btnL,"left");
  bindHold(btnR,"right");

  window.addEventListener("keydown",(e)=>{
    if (e.key==="ArrowUp") keys.gas=true;
    if (e.key==="ArrowDown") keys.brk=true;
    if (e.key==="ArrowLeft") keys.left=true;
    if (e.key==="ArrowRight") keys.right=true;
    if (e.key.toLowerCase()==="r") reset();
  });
  window.addEventListener("keyup",(e)=>{
    if (e.key==="ArrowUp") keys.gas=false;
    if (e.key==="ArrowDown") keys.brk=false;
    if (e.key==="ArrowLeft") keys.left=false;
    if (e.key==="ArrowRight") keys.right=false;
  });

  // --- Game state
  let crashed = false;
  let distM = 0;

  const state = {
    x: 0,
    z: 0,
    speed: 10.0,
    target: 14.0,
    steer: 0,
    jump: 0,   // >=0
    vy: 0,
    air: 0
  };

  function reset(){
    crashed = false;
    distM = 0;
    state.x = 0;
    state.z = 0;
    state.speed = 10.0;
    state.target = 14.0;
    state.steer = 0;
    state.jump = 0;
    state.vy = 0;
    state.air = 0;
    elSt.textContent = "Status: Running";
  }

  function crash(msg){
    crashed = true;
    elSt.textContent = "Status: üí• " + msg;
  }

  // --- NEW: Bike that ‚Äúfeels 3D‚Äù even without sprite
  function drawBike3D(){
    const bx = W/2 + (state.x / ROAD_W) * (W * 0.25);
    const lift = clamp(state.jump * 0.02, 0, 40);
    const by = H * 0.80 - lift + Math.sin(state.z*0.03)*2;

    const steer = clamp(state.steer, -1, 1);

    // Ground shadow (huge depth cue)
    const shadowScale = 1 + clamp(state.jump / 140, 0, 1.2);
    ctx.fillStyle = "rgba(0,0,0,0.45)";
    ctx.beginPath();
    ctx.ellipse(bx, H*0.80 + 46, 52*shadowScale, 14*shadowScale, 0, 0, Math.PI*2);
    ctx.fill();

    // Transform: yaw (squish), lean (rotate), speed scale
    const yawSquish = 1 - Math.abs(steer) * 0.35;
    const leanRot = -steer * 0.35;
    const speedScale = 1 + clamp((state.speed - 12)/40, 0, 0.18);

    ctx.save();
    ctx.translate(bx, by);
    ctx.rotate(leanRot);
    ctx.scale(0.58 * yawSquish * speedScale, 0.58 * speedScale);

    // Wheels
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.arc(-28, 22, 15, 0, Math.PI * 2);
    ctx.arc( 28, 22, 15, 0, Math.PI * 2);
    ctx.stroke();

    // Frame
    ctx.lineWidth = 7;
    ctx.beginPath();
    ctx.moveTo(-28, 22);
    ctx.lineTo(-6, -4);
    ctx.lineTo(28, 22);
    ctx.stroke();

    // Rider + helmet
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.arc(-10, -26, 12, 0, Math.PI * 2);
    ctx.fill();

    // Visor
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fillRect(-16, -30, 14, 6);

    // Handlebar
    ctx.strokeStyle = "rgba(255,255,255,0.92)";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(6, -10);
    ctx.lineTo(26, -20);
    ctx.stroke();

    ctx.restore();

    if (crashed){
      ctx.fillStyle="rgba(255,255,255,0.95)";
      ctx.font="800 34px system-ui,-apple-system,Segoe UI,Roboto,Arial";
      ctx.textAlign="center";
      ctx.fillText("üí• CRASH! Restart", W/2, H*0.42);
    }
  }

  function drawRuts(P1, P2, n){
    // simple rut lines
    ctx.strokeStyle = col.rut;
    ctx.lineWidth = Math.max(1, 2.2 * P2.scale);

    ctx.beginPath();
    ctx.moveTo(P1.x - P1.w*0.22, P1.y);
    ctx.lineTo(P2.x - P2.w*(0.22 + (n%3)*0.03), P2.y);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(P1.x + P1.w*0.22, P1.y);
    ctx.lineTo(P2.x + P2.w*(0.22 + (n%3)*0.03), P2.y);
    ctx.stroke();
  }

  function hud(){
    elSpd.textContent = `Speed: ${state.speed.toFixed(1)}`;
    elDst.textContent = `Dist: ${Math.floor(distM)}m`;
    elAir.textContent = `Air: ${state.air.toFixed(1)}s`;
  }

  function update(){
    if (crashed) return;

    const steerTarget = (keys.left ? -1 : 0) + (keys.right ? 1 : 0);
    state.steer += (steerTarget - state.steer) * 0.22;

    state.target = keys.gas ? 18.5 : 14.0;
    if (keys.brk) state.target = 7.5;

    state.speed += (state.target - state.speed) * 0.06;
    state.speed = clamp(state.speed, 0, 24);

    state.z += state.speed;
    distM += state.speed * 0.62;

    const i = segIndex(state.z);
    const cur = track[i].curve;

    // lateral + curve pull
    state.x += state.steer * (130 + state.speed*20);
    state.x -= cur * (state.speed * 105);

    // Jump model (stable)
    const hillNow = track[i].hill;
    const hillNext = track[(i+7)%track.length].hill;
    const crest = (hillNow - hillNext);

    state.vy += crest * 0.0042;
    state.vy -= 0.88;
    state.jump += state.vy;

    if (state.jump < 0){
      // landed
      if (state.air > 0.20 && Math.abs(state.vy) > 15.5) crash("Hard landing");
      state.jump = 0;
      state.vy *= -0.22;
      state.air *= 0.55;
    } else {
      state.air += 1/60;
    }

    if (Math.abs(state.x) > ROAD_W * 1.08) crash("Off track");
  }

  function render(){
    ctx.clearRect(0,0,W,H);
    sky();

    const idxNow = segIndex(state.z);
    const baseY = CAM_H + track[idxNow].hill;
    const camX = state.x;
    const camZ = state.z;
    const camY = baseY + state.jump;

    let maxY = H;
    let x = 0, dx = 0;

    for (let n=0; n<DRAW_DIST; n++){
      const idx = segIndex(camZ + n*SEG_LEN);
      const seg = track[idx];
      dx += seg.curve;

      const z1 = camZ + n*SEG_LEN;
      const z2 = camZ + (n+1)*SEG_LEN;

      const y1 = seg.hill;
      const y2 = track[segIndex(camZ + (n+1)*SEG_LEN)].hill;

      const P1 = project(x,      y1, z1, camX, camY, camZ);
      const P2 = project(x + dx, y2, z2, camX, camY, camZ);
      if (!P1 || !P2) continue;
      if (P2.y >= maxY) continue;
      maxY = P2.y;

      const grass = (n%2===0) ? col.grass1 : col.grass2;
      quad(W/2, P1.y, P1.w*2.45, W/2, P2.y, P2.w*2.45, grass);

      const dirt = (n%2===0) ? col.dirt1 : col.dirt2;
      quad(P1.x, P1.y, P1.w, P2.x, P2.y, P2.w, dirt, col.edge);

      drawRuts(P1, P2, n);

      // faint center line sometimes
      if (n%9 < 4){
        ctx.strokeStyle = col.line;
        ctx.lineWidth = Math.max(1, 1.5*P2.scale);
        ctx.beginPath();
        ctx.moveTo(P1.x, P1.y);
        ctx.lineTo(P2.x, P2.y);
        ctx.stroke();
      }
    }

    drawBike3D();
    hud();
  }

  function loop(){
    update();
    render();
    requestAnimationFrame(loop);
  }

  btnRs.addEventListener("click", reset);

  reset();
  loop();
})();
</script>
</body>
</html>