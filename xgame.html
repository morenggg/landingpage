<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Dorfduelli Racing ‚Äì Mini Game</title>
  <style>
    :root { --bg:#0b0b0b; --panel:#121212; --text:#eaeaea; --muted:#b7b7b7; }
    html, body { height:100%; margin:0; background:var(--bg); color:var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    .wrap { max-width: 900px; margin: 0 auto; padding: 16px 14px 80px; }
    h1 { font-size: 22px; margin: 8px 0 6px; }
    p { margin: 0 0 12px; color: var(--muted); }

    .hud { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin: 10px 0 12px; }
    .chip { background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); border-radius:999px; padding:8px 12px; font-size:14px; }
    button { background: rgba(255,255,255,.08); color:var(--text); border:1px solid rgba(255,255,255,.18);
      border-radius:12px; padding:10px 12px; font-size:14px; }
    button:active { transform: translateY(1px); }

    canvas { width:100%; height:auto; border-radius: 18px; background: radial-gradient(120% 140% at 50% 30%, #1a1a1a 0%, #0a0a0a 60%, #050505 100%);
      border:1px solid rgba(255,255,255,.12); touch-action: none; }

    .controls {
      position: fixed; left: 0; right: 0; bottom: 0; padding: 12px 14px calc(12px + env(safe-area-inset-bottom));
      backdrop-filter: blur(10px);
      background: linear-gradient(to top, rgba(0,0,0,.78), rgba(0,0,0,.28));
      border-top: 1px solid rgba(255,255,255,.10);
      display:flex; gap:12px; justify-content:center;
    }
    .pad {
      flex: 1; max-width: 420px;
      display:flex; gap:12px;
    }
    .pad button {
      flex: 1;
      height: 56px;
      font-size: 18px;
      border-radius: 16px;
    }
    .note { font-size: 12px; color: rgba(255,255,255,.55); margin-top: 10px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>üèçÔ∏è Mini Motorrad-Game</h1>
    <p>Tippe links/rechts (Handy) oder nutze ‚Üê ‚Üí (PC). Bleib auf der Strecke. Vollgas z√§hlt. üòÑ</p>

    <div class="hud">
      <div class="chip" id="speed">Speed: 0</div>
      <div class="chip" id="score">Score: 0</div>
      <div class="chip" id="status">Status: Ready</div>
      <button id="restart" type="button">Restart</button>
    </div>

    <canvas id="c" width="900" height="520" aria-label="Motorrad Game"></canvas>

    <div class="note">Tipp: Wenn du willst, bau ich dir als N√§chstes Obstacles (√ñlflecken üçå), M√ºnzen ü™ô und Highscore.</div>
  </div>

  <div class="controls">
    <div class="pad">
      <button id="left" type="button">‚¨ÖÔ∏è</button>
      <button id="right" type="button">‚û°Ô∏è</button>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const elSpeed = document.getElementById("speed");
  const elScore = document.getElementById("score");
  const elStatus = document.getElementById("status");
  const btnRestart = document.getElementById("restart");

  const btnLeft = document.getElementById("left");
  const btnRight = document.getElementById("right");

  // Game state
  const W = canvas.width, H = canvas.height;
  let running = true;
  let crashed = false;

  let t = 0;                 // time
  let score = 0;
  let speed = 6.2;           // forward speed
  let targetSpeed = 6.2;

  // Bike
  const bike = {
    x: W * 0.5,
    y: H * 0.72,
    vx: 0,
    steer: 0,               // -1..1
    lean: 0
  };

  // Track (center line oscillates)
  const track = {
    halfWidth: 160,
    softness: 0.12
  };

  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  function trackCenter(y, time) {
    // y 0..H => curve amount increases slightly with distance
    const n = y / H;
    const a = 110 + 70 * n; // amplitude
    return W * 0.5
      + a * Math.sin(time * 0.012 + n * 6.2)
      + 40 * Math.sin(time * 0.021 + n * 10.4);
  }

  function reset() {
    running = true;
    crashed = false;
    t = 0;
    score = 0;
    speed = 6.2;
    targetSpeed = 6.2;
    bike.x = W * 0.5;
    bike.vx = 0;
    bike.steer = 0;
    bike.lean = 0;
    elStatus.textContent = "Status: Ready";
  }

  // Input
  const keys = { left:false, right:false };

  window.addEventListener("keydown", (e) => {
    if (e.key === "ArrowLeft") keys.left = true;
    if (e.key === "ArrowRight") keys.right = true;
    if (e.key.toLowerCase() === "r") reset();
  });
  window.addEventListener("keyup", (e) => {
    if (e.key === "ArrowLeft") keys.left = false;
    if (e.key === "ArrowRight") keys.right = false;
  });

  function bindHold(btn, which) {
    const on = (ev) => { ev.preventDefault(); keys[which] = true; };
    const off = (ev) => { ev.preventDefault(); keys[which] = false; };
    btn.addEventListener("pointerdown", on);
    btn.addEventListener("pointerup", off);
    btn.addEventListener("pointercancel", off);
    btn.addEventListener("pointerleave", off);
  }
  bindHold(btnLeft, "left");
  bindHold(btnRight, "right");

  // Also allow tap on canvas sides
  canvas.addEventListener("pointerdown", (ev) => {
    const rect = canvas.getBoundingClientRect();
    const x = (ev.clientX - rect.left) / rect.width;
    keys.left = x < 0.5;
    keys.right = x >= 0.5;
  });
  canvas.addEventListener("pointerup", () => { keys.left = false; keys.right = false; });
  canvas.addEventListener("pointercancel", () => { keys.left = false; keys.right = false; });

  btnRestart.addEventListener("click", reset);

  // Draw helpers
  function drawTrack(time) {
    // Road gradient + dashed center line illusion
    const rows = 80;
    for (let i = 0; i < rows; i++) {
      const y0 = (i / rows) * H;
      const y1 = ((i + 1) / rows) * H;
      const yMid = (y0 + y1) * 0.5;

      const perspective = 0.32 + 0.68 * (yMid / H);
      const center = trackCenter(yMid, time);
      const half = track.halfWidth * perspective;

      // road
      ctx.fillStyle = `rgba(255,255,255,${0.05 + 0.07 * (1 - yMid / H)})`;
      ctx.fillRect(center - half, y0, half * 2, y1 - y0);

      // edges
      ctx.fillStyle = `rgba(255,255,255,${0.10 + 0.14 * (1 - yMid / H)})`;
      ctx.fillRect(center - half - 6, y0, 3, y1 - y0);
      ctx.fillRect(center + half + 3, y0, 3, y1 - y0);

      // center dashes
      const dashOn = ((time * 0.08 + i) % 10) < 5;
      if (dashOn) {
        ctx.fillStyle = `rgba(255,255,255,${0.22 + 0.10 * (1 - yMid / H)})`;
        ctx.fillRect(center - 2, y0, 4, y1 - y0);
      }
    }
  }

  function drawBike() {
    const x = bike.x;
    const y = bike.y;

    // shadow
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.beginPath();
    ctx.ellipse(x, y + 26, 30, 10, 0, 0, Math.PI * 2);
    ctx.fill();

    // bike body (simple stylized)
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(bike.lean * 0.45);

    // wheels
    ctx.strokeStyle = "rgba(255,255,255,0.85)";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(-18, 18, 12, 0, Math.PI * 2);
    ctx.arc(18, 18, 12, 0, Math.PI * 2);
    ctx.stroke();

    // frame
    ctx.strokeStyle = "rgba(255,255,255,0.9)";
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.moveTo(-18, 18);
    ctx.lineTo(0, -6);
    ctx.lineTo(18, 18);
    ctx.stroke();

    // rider
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.beginPath();
    ctx.arc(0, -18, 10, 0, Math.PI * 2);
    ctx.fill();

    // helmet visor
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fillRect(-7, -21, 14, 6);

    ctx.restore();

    // crash text
    if (crashed) {
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "700 34px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      ctx.fillText("üí• CRASH! Tippe Restart", W/2, H*0.46);
    }
  }

  function updateHUD() {
    elSpeed.textContent = `Speed: ${speed.toFixed(1)}`;
    elScore.textContent = `Score: ${Math.floor(score)}`;
    elStatus.textContent = crashed ? "Status: Crash" : "Status: Running";
  }

  function tick() {
    // update
    if (running && !crashed) {
      t += speed;

      // Steering input
      const steerTarget = (keys.left ? -1 : 0) + (keys.right ? 1 : 0);
      bike.steer += (steerTarget - bike.steer) * 0.22;

      // Slight speed increase over time (fun)
      targetSpeed = 6.2 + Math.min(4.0, score / 550);
      speed += (targetSpeed - speed) * 0.02;

      // move
      bike.vx += bike.steer * 0.85;
      bike.vx *= 0.86;
      bike.x += bike.vx;

      // lean
      bike.lean += (bike.vx * 0.03 - bike.lean) * 0.18;

      // Collision with track boundaries at bike y
      const center = trackCenter(bike.y, t);
      const half = track.halfWidth * (0.32 + 0.68 * (bike.y / H));
      const left = center - half + 10;
      const right = center + half - 10;

      if (bike.x < left || bike.x > right) {
        crashed = true;
        running = false;
      } else {
        score += speed * 0.8;
      }
    }

    // draw
    ctx.clearRect(0, 0, W, H);
    drawTrack(t);
    drawBike();
    updateHUD();

    requestAnimationFrame(tick);
  }

  reset();
  tick();
})();
</script>
</body>
</html>