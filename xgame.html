<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Dorfduelli Racing ‚Äì Motocross Mini</title>
  <style>
    :root { --bg:#070707; --fg:#f2f2f2; --muted:rgba(255,255,255,.65); }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}

    html, body, .controls, .pad, button, .chip, .note, p, h1 {
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }
    button{
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .wrap{max-width:980px;margin:0 auto;padding:14px 14px 88px}
    h1{font-size:22px;margin:6px 0 8px}
    p{margin:0 0 10px;color:var(--muted)}
    .hud{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin:10px 0 12px}
    .chip{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);border-radius:999px;padding:8px 12px;font-size:14px}
    button{background:rgba(255,255,255,.08);color:var(--fg);border:1px solid rgba(255,255,255,.18);border-radius:12px;padding:10px 12px;font-size:14px}
    button:active{transform:translateY(1px)}
    canvas{width:100%;height:auto;border-radius:18px;border:1px solid rgba(255,255,255,.12);touch-action:none;background:
      radial-gradient(120% 90% at 60% 20%, #1a1a1a 0%, #0a0a0a 55%, #050505 100%)}
    .controls{
      position:fixed;left:0;right:0;bottom:0;
      padding:12px 14px calc(12px + env(safe-area-inset-bottom));
      backdrop-filter:blur(10px);
      background:linear-gradient(to top, rgba(0,0,0,.78), rgba(0,0,0,.22));
      border-top:1px solid rgba(255,255,255,.10);
      display:flex;gap:12px;justify-content:center
    }
    .pad{flex:1;max-width:980px;display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:10px}
    .pad button{height:56px;font-size:16px;border-radius:16px}
    .note{font-size:12px;color:rgba(255,255,255,.55);margin-top:8px}
    .k{opacity:.9}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>üèÅ Motocross Mini</h1>
    <p><span class="k">Handy:</span> Buttons unten (Gas/Bremse/Lean). <span class="k">PC:</span> ‚Üê ‚Üí (Lean), ‚Üë Gas, ‚Üì Bremse, R Restart.</p>

    <div class="hud">
      <div class="chip" id="spd">Speed: 0</div>
      <div class="chip" id="dst">Dist: 0</div>
      <div class="chip" id="air">Air: 0.0s</div>
      <div class="chip" id="st">Status: Ready</div>
      <button id="rs" type="button">Restart</button>
    </div>

    <canvas id="c" width="980" height="520"></canvas>
    <div class="note">Fix: kein ‚ÄúKleben‚Äù auf Kuppen ‚Üí er springt sauber ab. Saltos in der Luft sind erlaubt.</div>
  </div>

  <div class="controls">
    <div class="pad">
      <button id="brk" type="button">üõë Bremse</button>
      <button id="l" type="button">‚¨ÖÔ∏è Lean</button>
      <button id="r" type="button">‚û°Ô∏è Lean</button>
      <button id="gas" type="button">üî• Gas</button>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const elSpd = document.getElementById("spd");
  const elDst = document.getElementById("dst");
  const elAir = document.getElementById("air");
  const elSt  = document.getElementById("st");
  const btnRs = document.getElementById("rs");

  const btnGas = document.getElementById("gas");
  const btnBrk = document.getElementById("brk");
  const btnL   = document.getElementById("l");
  const btnR   = document.getElementById("r");

  const W = canvas.width, H = canvas.height;

  // ===== Physics tuning =====
  const g = 0.38;             // etwas realistischer als 0.48; trotzdem airtime
  const wheelR = 12;
  const bikeLen = 56;

  const engineForce = 0.10;
  const brakeForce  = 0.18;

  const airPitch = 0.030;
  const stickiness = 0.26;

  const leanMax = 0.55;
  const leanSmooth = 0.12;

  // ‚úÖ Takeoff / Anti-Kleben (neu)
  const takeoffLook = 22;      // wie weit wir nach vorne schauen (px in world-x)
  const takeoffDrop = 6;      // ab wieviel "Boden f√§llt weg" wir abheben (px)
  const takeoffBoost = 2.1;    // zus√§tzlicher kleiner Lift beim Abheben

  // Track
  function heightAt(x) {
    let y = 370
      + 42 * Math.sin(x * 0.008)
      + 24 * Math.sin(x * 0.019 + 1.7)
      + 12 * Math.sin(x * 0.043 + 0.4);

    const bumps = [
      {x: 900,  w: 220, h: -55},
      {x: 1600, w: 260, h: -70},
      {x: 2450, w: 200, h: -62},
      {x: 3200, w: 280, h: -80},
      {x: 4100, w: 240, h: -68},
    ];
    for (const b of bumps) {
      const d = (x - b.x) / b.w;
      if (Math.abs(d) < 1.2) {
        const t = 1 - Math.min(1, Math.abs(d));
        y += b.h * (t * t * (3 - 2*t));
      }
    }
    return y;
  }
  function slopeAt(x) {
    const dx = 2.0;
    const y1 = heightAt(x - dx);
    const y2 = heightAt(x + dx);
    return Math.atan2(y2 - y1, dx * 2);
  }

  let camX = 0;

  const keys = { gas:false, brk:false, left:false, right:false };
  function bindHold(btn, k) {
    const on  = (e)=>{ e.preventDefault(); keys[k]=true; };
    const off = (e)=>{ e.preventDefault(); keys[k]=false; };
    btn.addEventListener("pointerdown", on);
    btn.addEventListener("pointerup", off);
    btn.addEventListener("pointercancel", off);
    btn.addEventListener("pointerleave", off);
  }
  bindHold(btnGas,"gas");
  bindHold(btnBrk,"brk");
  bindHold(btnL,"left");
  bindHold(btnR,"right");

  window.addEventListener("keydown",(e)=>{
    if (e.key==="ArrowUp") keys.gas=true;
    if (e.key==="ArrowDown") keys.brk=true;
    if (e.key==="ArrowLeft") keys.left=true;
    if (e.key==="ArrowRight") keys.right=true;
    if (e.key.toLowerCase()==="r") reset();
  });
  window.addEventListener("keyup",(e)=>{
    if (e.key==="ArrowUp") keys.gas=false;
    if (e.key==="ArrowDown") keys.brk=false;
    if (e.key==="ArrowLeft") keys.left=false;
    if (e.key==="ArrowRight") keys.right=false;
  });

  const bike = {
    x: 120, y: 0, vx: 0, vy: 0,
    rot: 0, rotV: 0,
    onGround: false,
    airTime: 0,
    wasAir: false,
    lastVy: 0,
    lean: 0
  };

  let crashed = false;
  let dist = 0;

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const wrapAngle = (a)=>{
    while (a > Math.PI) a -= Math.PI*2;
    while (a < -Math.PI) a += Math.PI*2;
    return a;
  };

  function reset() {
    camX = 0; dist = 0; crashed = false;
    bike.x = 120;
    bike.vx = 2.2;
    bike.vy = 0;
    bike.rot = 0;
    bike.rotV = 0;
    bike.airTime = 0;
    bike.wasAir = false;
    bike.lastVy = 0;
    bike.lean = 0;

    const gy = heightAt(bike.x);
    bike.y = gy - 55;
    elSt.textContent = "Status: Running";
  }

  function crash(msg) {
    crashed = true;
    elSt.textContent = "Status: üí• " + msg;
  }

  function drawBackground() {
    ctx.save();
    ctx.globalAlpha = 0.12;
    for (let i=0;i<60;i++){
      const x = (i*167 + (camX*0.2)) % (W+200) - 100;
      const y = (i*83) % (H*0.6);
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.restore();
  }

  function drawTrack() {
    ctx.save();
    ctx.translate(-camX, 0);

    ctx.beginPath();
    ctx.moveTo(camX - 200, H);
    const startX = Math.floor((camX - 200) / 8) * 8;
    const endX   = camX + W + 200;
    for (let x = startX; x <= endX; x += 8) ctx.lineTo(x, heightAt(x));
    ctx.lineTo(endX, H);
    ctx.closePath();

    ctx.fillStyle = "rgba(255,255,255,0.06)";
    ctx.fill();

    ctx.strokeStyle = "rgba(255,255,255,0.22)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let x = startX; x <= endX; x += 6) {
      const y = heightAt(x);
      if (x === startX) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();

    ctx.strokeStyle = "rgba(255,255,255,0.14)";
    for (let x = startX; x <= endX; x += 220) {
      const y = heightAt(x);
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x, y - 26);
      ctx.stroke();
      ctx.fillStyle = "rgba(255,255,255,0.12)";
      ctx.fillRect(x, y - 26, 14, 8);
    }

    ctx.restore();
  }

  function drawBike() {
    const sx = bike.x - camX;
    const sy = bike.y;

    const gy = heightAt(bike.x);
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.beginPath();
    ctx.ellipse(sx, gy + 10, 34, 10, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.save();
    ctx.translate(sx, sy);
    ctx.rotate(bike.rot);

    ctx.strokeStyle = "rgba(255,255,255,0.9)";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(-bikeLen/2, 16, wheelR, 0, Math.PI*2);
    ctx.arc( bikeLen/2, 16, wheelR, 0, Math.PI*2);
    ctx.stroke();

    ctx.strokeStyle = "rgba(255,255,255,0.95)";
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.moveTo(-bikeLen/2, 16);
    ctx.lineTo(-6, -2);
    ctx.lineTo( bikeLen/2, 16);
    ctx.stroke();

    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(6, -6);
    ctx.lineTo(22, -14);
    ctx.stroke();

    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.beginPath();
    ctx.arc(-6, -20, 10, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fillRect(-12, -24, 14, 6);

    ctx.restore();

    if (crashed) {
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "800 34px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      ctx.fillText("üí• CRASH! Restart", W/2, H*0.42);
    }
  }

  function hud() {
    elSpd.textContent = `Speed: ${Math.max(0,bike.vx).toFixed(1)}`;
    elDst.textContent = `Dist: ${Math.floor(dist)}m`;
    elAir.textContent = `Air: ${bike.airTime.toFixed(1)}s`;
  }

  function step() {
    if (!crashed) {
      bike.lastVy = bike.vy;

      // Gas + Bremse gleichzeitig: neutral / kein Chaos
      const both = keys.gas && keys.brk;
      if (!both && keys.gas) bike.vx += engineForce;
      if (keys.brk) bike.vx -= (both ? brakeForce * 0.35 : brakeForce);

      // Tempo begrenzen
      bike.vx *= 0.988;
      bike.vx = clamp(bike.vx, 0, 7.8);

      // Lean weicher
      const leanRaw = (keys.left ? -1 : 0) + (keys.right ? 1 : 0);
      bike.lean += (leanRaw - bike.lean) * leanSmooth;
      const lean = clamp(bike.lean, -1, 1);

      // wheel contacts
      const frontX = bike.x + bikeLen/2;
      const rearX  = bike.x - bikeLen/2;

      const groundF = heightAt(frontX);
      const groundR = heightAt(rearX);

      const wheelY = bike.y + 16;
      const touchF = wheelY + wheelR >= groundF;
      const touchR = wheelY + wheelR >= groundR;

      // ‚úÖ Anti-Kleben: wenn der Boden vor dir deutlich wegf√§llt -> TAKEOFF
      const midX = bike.x;
      const groundMid = heightAt(midX);
      const groundAhead = heightAt(midX + takeoffLook);
      const dropAhead = groundAhead - groundMid; // + = Boden f√§llt nach unten weg (y wird gr√∂√üer)

      const anyTouch = touchF || touchR;
      const bothTouch = touchF && touchR;

      // Standard: grounded wenn Kontakt
      bike.onGround = anyTouch;

      // Takeoff-Trigger: nicht beide R√§der sauber drauf UND Boden f√§llt weg
      if (anyTouch && !bothTouch && dropAhead > takeoffDrop) {
        bike.onGround = false;
        bike.wasAir = true;
        bike.airTime = Math.max(bike.airTime, 0.001);

        // kleiner Lift: abh√§ngig von drop + speed (aber gedeckelt)
        const lift = clamp(dropAhead * 0.10 + bike.vx * 0.06, 0.6, 2.8) * takeoffBoost;
        bike.vy = Math.min(bike.vy, -lift);
      }

      if (bike.onGround) {
        // ‚úÖ Snap auf Durchschnitt beider R√§der -> weniger ‚ÄúHaken‚Äù an Kuppen
        const groundAvg = (groundF + groundR) * 0.5;
        bike.y = groundAvg - (16 + wheelR) - 18;

        const slope = slopeAt(midX);
        bike.rot += (slope - bike.rot) * stickiness;
        bike.rot += lean * leanMax * 0.006;
        bike.rotV *= 0.4;

        // Crash nur beim Landen
        const justLanded = bike.wasAir && bike.airTime > 0.10;
        if (justLanded) {
          const rel = Math.abs(wrapAngle(bike.rot - slope));
          const impact = Math.abs(bike.lastVy);

          const upsideDown = rel > 2.4;
          const tooSteep   = rel > 1.45;
          const hardHit    = impact > 4.2;

          if (upsideDown) crash("Upside down");
          else if (tooSteep && hardHit) crash("Bad landing");
        }

        bike.vy = 0;
        bike.airTime = 0;
        bike.wasAir = false;

        bike.y += Math.sin(dist * 0.05) * 0.2;

      } else {
        // Airborne
        bike.vy += g;
        bike.y += bike.vy;

        bike.airTime += 1/60;

        // Saltos erlaubt: keine Air-crash rule
        bike.rotV += lean * leanMax * airPitch;
        bike.rotV *= 0.985;
        bike.rot = wrapAngle(bike.rot + bike.rotV);

        bike.wasAir = true;
      }

      bike.x += bike.vx;
      dist += bike.vx * 0.6;

      camX += ((bike.x - W*0.35) - camX) * 0.08;

      if (bike.vx < 0.05 && dist > 20) crash("Stopped");
    }

    ctx.clearRect(0,0,W,H);
    drawBackground();
    drawTrack();
    drawBike();
    hud();

    requestAnimationFrame(step);
  }

  btnRs.addEventListener("click", reset);

  reset();
  step();
})();
</script>
</body>
</html>